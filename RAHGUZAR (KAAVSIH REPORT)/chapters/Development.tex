The development of Rahguzar was guided by the goal of building a robust, scalable, and user-friendly platform capable of automating Permanent Journey Plan (PJP) scheduling in FMCG field operations. The project was developed in phases, each aligning with different milestones from backend API construction to frontend deployment, database integration, and cloud migration.

\section{Backend Development and API Architecture}
The backend of Rahguzar was developed using Flask, a lightweight Python-based microframework. Flask was chosen for its flexibility and simplicity, allowing us to quickly develop RESTful APIs that catered to the core functionalities of route generation, user management, and data synchronization. The API layer served as the communication bridge between the frontend and the backend logic, as well as with third-party services like Google Maps.

The route optimization engine was integrated into this backend stack using custom Python scripts and OR-Tools for solving routing problems. This engine consumed input parameters—such as store locations, visit frequencies, shift timings, and the number of available order bookers—and returned optimized PJPs. These responses were served through API endpoints that exposed functionalities for plan generation, route export, real-time updates, and manual overrides.

Throughout development, emphasis was placed on designing clean, modular API endpoints. Authentication and authorization mechanisms were implemented using JSON Web Tokens (JWT), ensuring secure access control for different types of users, particularly field managers.

\section{Frontend Development with React}
The frontend was implemented using React, which offered a highly responsive and component-driven interface for interacting with Rahguzar's planning and monitoring features. React’s ability to efficiently manage state and update the DOM in real-time was crucial for building features like dynamic map rendering, drag-and-drop store reordering, and dashboard KPI tracking.

The user interface included several key screens such as the sign-in and registration pages, a dashboard with route statistics, a map-based route planner, and modules for viewing stores and journeys. Special attention was given to providing managers with a seamless experience for planning, editing, and visualizing routes, supported by an interactive map powered by the Google Maps API.

Frontend and backend integration was handled via asynchronous API calls using Axios. These calls ensured real-time feedback during route planning sessions, allowing users to view updated PJPs instantly after adjusting route parameters or filters.

\section{Database Design and Integration}
Initially, PostgreSQL was selected as the relational database for managing store profiles, visit logs, user data, and system configurations. The schema was normalized and designed to accommodate the system's growing need for relational queries, especially during the optimization phase where data consistency and referential integrity were crucial.

The data design followed an entity-relationship model, with core tables representing stores, visits, routes, and users. Each route was linked to a cluster of stores and assigned to specific order bookers based on availability and priority. Visit records captured timestamps, sync states, and performance metrics for later analysis.

During development, we encountered limitations with local hosting, especially as the dataset size and user load increased. This led to the decision to migrate the database to a cloud-hosted environment.

\section{Migration to AWS RDS}
To ensure scalability, reliability, and modular deployment, the Rahguzar system was migrated entirely to Amazon Web Services (AWS). Each core component—frontend, backend, database, and routing engine—was deployed on an independent cloud-managed or containerized service, enhancing system maintainability and operational separation.

The frontend interface, developed using React, was hosted on an EC2 instance and served through Nginx. This configuration allowed for high-speed static content delivery and responsive user interaction, even under concurrent access. Using EC2 provided flexibility for auto-scaling based on usage, ensuring the interface remained consistent and efficient during pilot testing.

The backend, built with Flask, was deployed on a separate EC2 instance and served via Gunicorn to handle multiple simultaneous API requests. As the central orchestrator of the system, the backend coordinated data flow between the user interface, database, and routing engine. This separation of services ensured robust handling of real-time scheduling, clustering, and route generation logic.

The PostgreSQL database was migrated to Amazon RDS. The process involved exporting local snapshots and restoring them into a managed RDS instance, followed by reconfiguring the Flask backend to use cloud-based credentials and environment-secured variables. IAM role-based access was used to manage security and ensure compliance. RDS offered operational benefits such as automated backups, failover recovery, and real-time monitoring through CloudWatch. Post-migration, the system demonstrated marked improvements in query performance and concurrency, particularly during route generation and analytics operations.

For route optimization, the Open Source Routing Machine (OSRM) was containerized using Docker and exposed via Ngrok. This setup enabled secure, encrypted communication with the backend while keeping the container isolated from public networks. OSRM processed map-based routing queries with real-world accuracy, integrating seamlessly into the scheduling workflow.

Collectively, this AWS deployment enabled the Rahguzar system to operate with cloud-native resilience, modular scalability, and rapid performance. It formed a reliable foundation for future expansions across cities and regions, ready to serve field teams and decision-makers in large-scale FMCG environments.
\section{Integration with External Services}
Mapping functionality was powered by the Google Maps API, which was integrated into both the backend and frontend layers. On the backend, it was used to compute distance matrices between store locations for the route optimization engine. On the frontend, it enabled real-time map rendering, location-based filtering, and drawing of optimized route paths.

Additionally, Geopy was used for geospatial computations, such as distance calculations and reverse geocoding, complementing the Google Maps integration. These services allowed for a smooth and data-accurate user experience when planning and viewing routes.

\section{Testing and Deployment}
Throughout development, both unit and integration tests were written to ensure API stability and frontend-backend communication integrity. Postman and pytest were used for backend testing, while Cypress and manual QA testing supported frontend validation.

The final deployment used an EC2-based architecture for the backend Flask server, React served via an S3 bucket and CloudFront, and PostgreSQL managed through AWS RDS. This cloud-based setup ensured high uptime, fast response times, and readiness for real-world deployment at scale.