The development of Rahguzar was guided by the goal of building a robust, scalable, and user-friendly platform capable of automating Permanent Journey Plan (PJP) scheduling in FMCG field operations. The project was developed in phases, each aligning with different milestones from backend API construction to frontend deployment, database integration, and cloud migration.

\section{Backend Development and API Architecture}
The backend of Rahguzar was developed using Flask, a lightweight Python-based microframework. Flask was chosen for its flexibility and simplicity, allowing us to quickly develop RESTful APIs that catered to the core functionalities of route generation, user management, and data synchronization. The API layer served as the communication bridge between the frontend and the backend logic, as well as with third-party services.

The route optimization engine was integrated into this backend stack using custom Python scripts for solving routing problems. This engine consumed input parameters—such as store locations, visit frequencies, shift timings, and the number of available order bookers—and returned optimized PJPs. These responses were served through API endpoints that exposed functionalities for plan generation, route export, real-time updates, and manual overrides.

Throughout development, emphasis was placed on designing clean, modular API endpoints. Authentication and authorization mechanisms were implemented using JSON Web Tokens (JWT), ensuring secure access control for different types of users, particularly field managers.

\section{Frontend Development with React}
The frontend was implemented using React, which offered a highly responsive and component-driven interface for interacting with Rahguzar's planning and monitoring features. React’s ability to efficiently manage state and update the DOM in real-time was crucial for building features like dynamic map rendering, drag-and-drop store reordering, and dashboard KPI tracking.

The user interface included several key screens such as the sign-in, a dashboard with route statistics, a map-based schedule and route planner, and modules for viewing stores and journeys. Special attention was given to providing managers with a seamless experience for planning, editing, and visualizing routes, supported by an interactive map.

Frontend and backend integration was handled via asynchronous API calls using Axios. These calls ensured real-time feedback during route planning sessions, allowing users to view updated PJPs instantly after adjusting route parameters or filters.

\section{Database Design and Integration}
PostgreSQL was chosen from the outset as the primary relational database to manage store profiles, visit logs, user information, and system configurations. The database schema was carefully normalized to support complex relational queries and ensure data consistency—especially critical during the optimization phase, where referential integrity and transactional reliability were essential.

The design followed an entity-relationship model, with core tables representing entities such as stores, visits, routes, and users. Each route entry was linked to a cluster of stores and assigned to a specific order booker based on priority and availability. Visit records captured detailed metadata including timestamps, sync states, and performance metrics, supporting both real-time operations and historical analysis.

From the beginning, the system architecture accounted for future scaling needs. While local hosting was used during early development, migrating the PostgreSQL database to a cloud environment was always part of the deployment roadmap. This foresight allowed us to choose a relational database that could easily transition to cloud services without significant rework.

\section{Migration to AWS and Cloud Deployment}

To ensure cost-effective scalability and streamlined management, the Rahguzar system was migrated to Amazon Web Services (AWS). All core components—including the frontend interface, backend logic, routing engine, and database client—were deployed on a single \texttt{t3.medium} EC2 instance. This consolidated deployment simplified system configuration, reduced latency between services, and ensured consistent performance during pilot testing.

The frontend, built using React, was compiled locally and deployed on the EC2 instance using Nginx to serve static assets. This allowed for efficient content delivery and responsive user interaction, even during concurrent access by multiple users. The backend, implemented in Flask, was hosted on the same instance and served via Gunicorn. It acted as the central controller for all major operations including store clustering, Evolutionary Algorithm-based scheduling, route optimization, and communication with both the routing engine and the database.

The Open Source Routing Machine (OSRM) was containerized using Docker and also deployed on the EC2 instance. It was used to compute real-world road routes and travel times between store locations. The backend accessed OSRM via local RESTful API calls, retrieving optimized polylines and distance estimates that were directly integrated into the scheduling logic and frontend map rendering. OSRM was configured to run privately within the EC2 environment, ensuring that routing operations remained secure and isolated from public access.

In parallel with the EC2 setup, the PostgreSQL database was migrated from a local development environment to Amazon RDS. The migration process involved exporting local snapshots and importing them into a managed PostgreSQL instance on RDS. Following the migration, the Flask backend was reconfigured to connect securely to RDS using environment-secured credentials. To ensure security, inbound traffic to the RDS instance was restricted to only allow requests from the EC2 instance. The use of RDS provided several operational advantages, including automated backups, failover recovery, and real-time performance monitoring through AWS CloudWatch. These features contributed to improved database reliability and enhanced query performance, especially during intensive route generation and dashboard analytics tasks.

All inter-service communication occurred within the EC2 instance or over secured private channels, with environment variables used to manage API keys and database credentials securely. Although this architecture runs all services on a single machine, it is designed for modular scaling. As system usage grows, individual components can be independently scaled or containerized further without requiring architectural changes. This deployment forms a stable, cloud-native foundation that is capable of supporting Rahguzar’s expansion into multiple regions and cities within the FMCG domain.

\section{Integration with External Services}

The Rahguzar system integrates key external services to enable accurate, real-world route optimization and dynamic geospatial visualization. These integrations play a critical role in both the backend logic responsible for route computation and the frontend interface that supports interactive user experiences.

The Open Source Routing Machine (OSRM) is deployed as a Docker container on the same AWS EC2 instance that hosts the rest of the system. Serving as the core routing engine, OSRM processes map-based routing queries using preprocessed OpenStreetMap (OSM) data. It computes real-world travel distances and optimal driving paths between store locations, which are essential inputs for the route optimization workflow. The Flask backend communicates with OSRM through RESTful API calls using endpoints. These endpoints return data including total travel time, total distance, and a GeoJSON-encoded polyline representing the optimized route geometry. This data is used to generate routes that reflect real driving conditions and constraints, enhancing the operational feasibility of the journey plans.

On the frontend, Leaflet.js is used to render interactive maps within the React interface. It visualizes optimized routes, displays store markers, and supports features such as polygon selection and zoom-based filtering. The route geometry returned by OSRM integrates seamlessly with Leaflet’s polyline rendering features, enabling the display of accurate road-based paths instead of abstract straight-line connections. Additional customization, such as colored cluster markers and dynamic route overlays, is implemented using Leaflet’s plugin architecture and open API design. Together, the integration of OSRM and Leaflet enables a robust map-based planning experience for managers and provides clear, actionable route visualization for field teams.

\section{Testing and Deployment}
Throughout development, both unit and integration tests were written to ensure API stability and frontend-backend communication integrity. Postman and pytest were used for backend testing, while Cypress and manual QA testing supported frontend validation.

The final deployment used an EC2-based architecture for the backend Flask server, React served via an S3 bucket and CloudFront, and PostgreSQL managed through AWS RDS. This cloud-based setup ensured high uptime, fast response times, and readiness for real-world deployment at scale.